{
  "language": "Solidity",
  "sources": {
    "contracts/USDCRewardClaim.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\n\n/**\n * @title USDCRewardClaim\n * @dev Smart contract for claiming USDC rewards with signed authorization from booth staff\n * Deployed on Base network\n */\ncontract USDCRewardClaim is Ownable {\n    using ECDSA for bytes32;\n    using MessageHashUtils for bytes32;\n\n    // USDC token address on Base mainnet\n    IERC20 public immutable usdcToken;\n    \n    // Reward amount in USDC (1 USDC = 1e6 for USDC decimals)\n    uint256 public constant REWARD_AMOUNT = 1e6; // 1 USDC\n    \n    // Booth staff address authorized to sign claims\n    address public boothStaff;\n    \n    // Track which email hashes have claimed\n    mapping(bytes32 => bool) public hasClaimed;\n    \n    // Track used nonces to prevent replay attacks\n    mapping(uint256 => bool) public usedNonces;\n    \n    // Events\n    event RewardClaimed(\n        bytes32 indexed emailHash,\n        address indexed recipient,\n        uint256 amount,\n        uint256 nonce\n    );\n    \n    event BoothStaffUpdated(address indexed oldStaff, address indexed newStaff);\n    event ContractFunded(address indexed funder, uint256 amount);\n    event EmergencyWithdraw(address indexed recipient, uint256 amount);\n    \n    /**\n     * @dev Constructor\n     * @param _usdcToken Address of USDC token on Base\n     * @param _boothStaff Initial booth staff address\n     */\n    constructor(address _usdcToken, address _boothStaff) Ownable(msg.sender) {\n        require(_usdcToken != address(0), \"Invalid USDC address\");\n        require(_boothStaff != address(0), \"Invalid booth staff address\");\n        \n        usdcToken = IERC20(_usdcToken);\n        boothStaff = _boothStaff;\n    }\n    \n    /**\n     * @dev Claim USDC reward with signed authorization\n     * @param emailHash Keccak256 hash of user's email\n     * @param walletAddress Address to receive the USDC\n     * @param nonce Unique nonce for this claim\n     * @param signature Signature from booth staff authorizing the claim\n     */\n    function claimReward(\n        bytes32 emailHash,\n        address walletAddress,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        require(walletAddress != address(0), \"Invalid wallet address\");\n        require(!hasClaimed[emailHash], \"Email has already claimed\");\n        require(!usedNonces[nonce], \"Nonce already used\");\n        \n        // Verify signature\n        bytes32 messageHash = getMessageHash(emailHash, walletAddress, nonce);\n        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();\n        \n        address signer = ethSignedMessageHash.recover(signature);\n        require(signer == boothStaff, \"Invalid signature\");\n        \n        // Mark as claimed\n        hasClaimed[emailHash] = true;\n        usedNonces[nonce] = true;\n        \n        // Transfer USDC\n        require(\n            usdcToken.transfer(walletAddress, REWARD_AMOUNT),\n            \"USDC transfer failed\"\n        );\n        \n        emit RewardClaimed(emailHash, walletAddress, REWARD_AMOUNT, nonce);\n    }\n    \n    /**\n     * @dev Get the message hash for signing\n     * @param emailHash Keccak256 hash of user's email\n     * @param walletAddress Address to receive the USDC\n     * @param nonce Unique nonce\n     */\n    function getMessageHash(\n        bytes32 emailHash,\n        address walletAddress,\n        uint256 nonce\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(emailHash, walletAddress, nonce));\n    }\n    \n    /**\n     * @dev Update booth staff address\n     * @param newBoothStaff New booth staff address\n     */\n    function updateBoothStaff(address newBoothStaff) external onlyOwner {\n        require(newBoothStaff != address(0), \"Invalid booth staff address\");\n        address oldStaff = boothStaff;\n        boothStaff = newBoothStaff;\n        emit BoothStaffUpdated(oldStaff, newBoothStaff);\n    }\n    \n    /**\n     * @dev Fund the contract with USDC\n     * Note: Requires prior approval of USDC transfer\n     * @param amount Amount of USDC to fund (in USDC's decimals, e.g., 10e6 for 10 USDC)\n     */\n    function fundContract(uint256 amount) external {\n        require(amount > 0, \"Amount must be greater than 0\");\n        \n        require(\n            usdcToken.transferFrom(msg.sender, address(this), amount),\n            \"USDC transfer failed\"\n        );\n        \n        emit ContractFunded(msg.sender, amount);\n    }\n    \n    /**\n     * @dev Emergency withdraw USDC from contract\n     * @param amount Amount to withdraw\n     * @param recipient Address to send USDC to\n     */\n    function emergencyWithdraw(uint256 amount, address recipient) external onlyOwner {\n        require(recipient != address(0), \"Invalid recipient\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        \n        uint256 balance = usdcToken.balanceOf(address(this));\n        require(balance >= amount, \"Insufficient balance\");\n        \n        require(\n            usdcToken.transfer(recipient, amount),\n            \"USDC transfer failed\"\n        );\n        \n        emit EmergencyWithdraw(recipient, amount);\n    }\n    \n    /**\n     * @dev Get contract USDC balance\n     */\n    function getBalance() external view returns (uint256) {\n        return usdcToken.balanceOf(address(this));\n    }\n    \n    /**\n     * @dev Check if an email has claimed\n     * @param emailHash Keccak256 hash of email\n     */\n    function hasEmailClaimed(bytes32 emailHash) external view returns (bool) {\n        return hasClaimed[emailHash];\n    }\n    \n    /**\n     * @dev Check if a nonce has been used\n     * @param nonce The nonce to check\n     */\n    function isNonceUsed(uint256 nonce) external view returns (bool) {\n        return usedNonces[nonce];\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "shanghai",
    "outputSelection": {
      "*": {
        "*": ["abi", "evm.bytecode", "evm.deployedBytecode", "metadata"]
      }
    }
  }
}

